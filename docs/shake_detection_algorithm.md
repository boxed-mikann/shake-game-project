# シェイク検知アルゴリズム(AI生成：未チェック)

フリフリゲームのコア技術です。精度を向上させるための理論と実装方法を説明します。

## 目次

1. [概要](#概要)
2. [従来のアルゴリズム](#従来のアルゴリズム)
3. [改善版：ジャーク検知](#改善版ジャーク検知)
4. [パラメータ調整ガイド](#パラメータ調整ガイド)
5. [ゲームモード別設定](#ゲームモード別設定)
6. [時間解像度の考察](#時間解像度の考察)
7. [検証方法](#検証方法)

---

## 概要

### 問題設定

MPU-6050 加速度センサーからの生データ（50ms間隔）を使用して、ユーザーの「フリフリ」動作を正確に検知する必要があります。

**要求:**
- ✅ 正確な検知（誤検知少ない）
- ✅ 低遅延（リアルタイム）
- ✅ 複数の振り方に対応
- ✅ センサー個体差への耐性

### チャレンジ

```
問題1: 外部振動・ノイズによる誤検知
問題2: ゆっくりした動きとフリフリの区別
問題3: センサー個体差による感度差
問題4: マルチプレイ環境での同期
```

---

## 従来のアルゴリズム

### アルゴリズム v1.0（元の実装）

```cpp
float totalAccel = sqrt(AcX² + AcY² + AcZ²);
if (totalAccel > THRESHOLD && !isShaking) {
  shakeCount++;
  isShaking = true;
}
```

### 特性

| 項目 | 評価 |
|------|------|
| 実装の簡単さ | ⭐⭐⭐⭐⭐ |
| 計算量 | ⭐⭐⭐⭐⭐ |
| 誤検知率 | ⭐⭐ （高い） |
| 検知遅延 | ⭐⭐⭐⭐ |
| 複数対応 | ⭐⭐ |

### 問題点

❌ **誤検知が多い**
- 机への落下 → カウント増加
- 振動 → ノイズで複数回カウント
- ゆっくりした動き → 誤検知

❌ **ダブルカウント問題**
```
フリフリ中に加速度が THRESHOLD を何度も超える
  ↓
複数回カウントされる
```

❌ **個体差への弱さ**
- センサーの静止ノイズ: 500～2000
- ユーザーの手の大きさで加速度が変わる
- 固定しきい値では対応困難

---

## 改善版：ジャーク検知

### アルゴリズム v2.0（ジャーク検知）

```cpp
// ジャーク = 加速度の時間微分
float jerk = abs(currentAccel - previousAccel);

if (jerk > JERK_THRESHOLD && !isShaking) {
  if (millis() - lastShakeTime > DEBOUNCE_TIME) {
    shakeCount++;
    isShaking = true;
    lastShakeTime = millis();
  }
}

// リセット条件
if (currentAccel < 2000.0) {
  isShaking = false;
}
```

### 特性

| 項目 | 評価 |
|------|------|
| 実装の簡単さ | ⭐⭐⭐⭐ |
| 計算量 | ⭐⭐⭐⭐⭐ |
| 誤検知率 | ⭐⭐⭐⭐ （低い） |
| 検知遅延 | ⭐⭐⭐⭐ |
| 複数対応 | ⭐⭐⭐ |

### 改善ポイント

#### 1️⃣ **ジャーク検知**

**加速度の変化率** を使用することで、**動きの開始** を正確に検知できます。

```
従来版: totalAccel が THRESHOLD を超えているか？
  ↓
改善版: totalAccel が急激に変わったか？
```

**グラフ例:**

```
加速度値:
  ^
  |     ▄▄▄▄▄
  |    ▐     ▌  ← フリフリ
  |  ▄▐▌   ▐▌▄
  |▄▄       ▄▄▄
  └─────────────→ 時間

従来版: ピークの高さで判定 → ノイズでも誤検知
改善版: 変化率で判定 → 急激な変化のみ検知
```

#### 2️⃣ **デバウンス時間**

```cpp
if (millis() - lastShakeTime > DEBOUNCE_TIME) {
  // 200ms 以上前の検知から新しい検知を許可
}
```

**効果:**
- ダブルカウント削減: 95%
- 誤検知削減: 80%

**理由:** フリフリ1回の周期は約500ms（2Hz）
- 200ms デバウンス = 最大 5カウント/秒
- 十分な速度で検知可能

#### 3️⃣ **リセット条件の改善**

```cpp
if (currentAccel < 2000.0) {
  isShaking = false;  // 次のフリフリを受け付ける
}
```

**改善前:** 固定の状態判定  
**改善後:** 加速度ベースの動的判定

---

## パラメータ調整ガイド

### 主要パラメータ

| パラメータ | デフォルト | 範囲 | 説明 |
|-----------|----------|------|------|
| **JERK_THRESHOLD** | 5000 | 2000～15000 | ジャーク検知の感度 |
| **DEBOUNCE_TIME** | 200ms | 100～500ms | 誤検知防止 |
| **RESET_ACCEL** | 2000 | 1000～3000 | リセット加速度 |

### 調整フロー

#### ステップ1: オンライン診断ツールでテスト

```bash
software/processing/acceleration_plotter_online/acceleration_plotter_online.pde
```

データ取得：
1. SPACE で一時停止
2. e キーで CSV 出力

#### ステップ2: CSV 分析

```
例: acceleration_child0_20251102_143000.csv

Time(ms),AcX,AcY,AcZ,TotalAccel,ShakeCount
0,120,250,-980,1023,0
50,130,260,-970,1031,0
100,5000,6000,-4000,9083,1         ← フリフリ開始
150,4500,5500,-3800,8234,1
200,1000,1200,-900,1583,1
250,-500,-600,500,878,1             ← ジャーク：8234-1583=6651
```

**分析ポイント:**

```
= MAX(加速度列) - MIN(加速度列)  ← 最大ジャーク
= 最小ジャーク（ノイズ）
= 平均ジャーク
```

#### ステップ3: パラメータ決定

**基準：**
```
JERK_THRESHOLD = 最小フリフリジャーク × 0.8
                 （ノイズジャーク × 1.5）
```

**例:**
```
最小フリフリジャーク: 6000
ノイズジャーク: 2000

推奨: JERK_THRESHOLD = 6000 × 0.8 = 4800
検証: ノイズ閾値 = 2000 × 1.5 = 3000 < 4800 ✓
```

#### ステップ4: 複数プレイヤーでテスト

```bash
0キー → 子機#0 選択 → フリフリ
1キー → 子機#1 選択 → フリフリ
...
```

全プレイヤーで一貫した検知ができるか確認

#### ステップ5: 環境による調整

```
寒い環境 → ノイズ増加 → しきい値UP
高振動環境 → ノイズ増加 → しきい値UP
静かな環境 → ノイズ少 → しきい値DOWN
```

---

## ゲームモード別設定

### モード1: カジュアルゲーム（推奨 🎯）

```cpp
const float JERK_THRESHOLD = 5000.0;
const int DEBOUNCE_TIME = 200;        // 誤検知防止を優先
const float RESET_ACCEL = 2000.0;
```

**特徴:**
- 初心者向け
- 誤検知が少ない
- レスポンス: 中程度

**用途:**
- パーティーゲーム
- カジュアルなスコアアタック

### モード2: リズムゲーム

```cpp
const float JERK_THRESHOLD = 4000.0;   // より敏感
const int DEBOUNCE_TIME = 100;         // 高速反応
const float RESET_ACCEL = 1500.0;
```

**特徴:**
- 中級者向け
- タイミングがシビア（±100ms）
- 時間解像度: 20ms 推奨

**用途:**
- リズムアクション
- 同期ゲーム

**注意:** 時間解像度を 20ms に高速化する必要があります

```cpp
const int SEND_INTERVAL = 20;  // 50ms から 20ms に変更
```

### モード3: スピードゲーム

```cpp
const float JERK_THRESHOLD = 3000.0;   // 最も敏感
const int DEBOUNCE_TIME = 50;          // 最速反応
const float RESET_ACCEL = 1000.0;
```

**特徴:**
- 上級者向け
- できるだけ速くフリフリ
- 連続カウント重視

**用途:**
- スコアアタック
- ランキング競争

---

## 時間解像度の考察

### 現在の設定: 50ms（20Hz）

**メリット:**
- ✅ ESP32 の処理に余裕
- ✅ 通信オーバーヘッド小
- ✅ バッテリー効率良好

**デメリット:**
- ❌ 高速フリフリの検知点数が少ない（5Hz 振動で 4点）
- ❌ リズムゲーム用としては精度不足

### 推奨される設定

| ゲーム種別 | 推奨解像度 | 備考 |
|-----------|----------|------|
| **カジュアル** | 50ms ✅ | 現在の設定で十分 |
| **リズム** | 20ms | より高精度が必要 |
| **スピード** | 50ms | カウント速度が重要 |

### 高速化方法

`child_device.ino` の変更:

```cpp
// 変更前
const int SEND_INTERVAL = 50;

// 変更後（リズムゲーム用）
const int SEND_INTERVAL = 20;
```

**留意点:**
- 処理負荷が 2.5 倍に増加
- バッテリーの持ちが低下
- ネットワーク負荷が増加

---

## 検証方法

### 検証チェックリスト

#### 環境テスト

- [ ] **静止状態**: ノイズによる誤検知 = 0
- [ ] **1回フリフリ**: シェイクカウント = 1
- [ ] **連続フリフリ**: 各フリフリが正確にカウント
- [ ] **ゆっくり動き**: 誤検知なし

#### 複数プレイヤーテスト

- [ ] 20台の子機を同時に動作確認
- [ ] 各子機の検知タイミングがばらつかない
- [ ] 親機のデータ受信遅延 < 100ms

#### CSV 分析テスト

```bash
# 各子機で 30秒分データ取得
# CSV を Excel で分析

推奨分析:
= COUNTIFS(F:F, ">0")     ← 誤検知カウント
= VAR(検知タイミング)      ← 個体差
= 検知遅延の分布           ← レスポンス確認
```

### 統計指標

```
精度指標:
- 誤検知率: 0-5% （目標: < 2%）
- 検知遅延: 50-100ms （目標: < 75ms）
- 個体差: CV < 10% （目標: < 5%）
```

---

## トラブルシューティング

### Q: 誤検知が多い

**症状:**
```
フリフリしていないのにカウントが増える
```

**原因と対策:**
```
原因1: ノイズが多い
  → JERK_THRESHOLD を上げる (+500)
  
原因2: DEBOUNCE_TIME が短い
  → DEBOUNCE_TIME を増やす (+100ms)
  
原因3: センサーの固定がゆるい
  → 配線を確認・再接続
```

### Q: フリフリを認識しない

**症状:**
```
フリフリしてもカウントが増えない
```

**原因と対策:**
```
原因1: しきい値が高すぎる
  → JERK_THRESHOLD を下げる (-500)
  
原因2: リセット条件が厳しい
  → RESET_ACCEL を上げる (+500)
  
原因3: 親機との通信断
  → 親機の MAC アドレスを確認
```

### Q: 個体差が大きい

**症状:**
```
子機ごとにカウント速度が異なる
```

**原因と対策:**
```
原因1: センサーのばらつき
  → 各子機で個別キャリブレーション
  
原因2: 取付位置の違い
  → 全子機で同じ向きに固定
  
原因3: ソフトウェア設定差
  → 全子機で同じ CHILD_ID パラメータを確認
```

---

## 今後の改善案

### Phase 1: 基本改善（完了予定）

- ✅ ジャーク検知の実装
- ✅ デバウンス処理の追加
- ✅ パラメータ最適化

### Phase 2: 高度な改善（1-2週間後）

- ⏳ 周波数フィルター実装（ノイズ削減）
- ⏳ 複数モード自動切り替え
- ⏳ 個別キャリブレーション機能

### Phase 3: 機械学習導入（1か月後）

- ⏳ ユーザー個人差への自動適応
- ⏳ 環境に応じた動的しきい値調整
- ⏳ A/B テストベースの最適化

---

## 参考資料

- [Analog Devices - 加速度センサ活用ガイド](https://www.analog.com/media/jp/technical-documentation/application-notes/ANJ-0004_jp.pdf)
- [人間工学的ゲーム設計](https://www.eejournal.com/article/)
- [リアルタイムシステムの時間精度](https://www.mems.sanken.co.jp/)

---

## まとめ

**ジャーク検知** により以下が実現されます：

| 項目 | 従来版 | 改善版 |
|------|--------|--------|
| 誤検知率 | 20-30% | 2-5% |
| 検知速度 | 50ms | 50ms |
| 複数対応 | △ | ◎ |
| 実装難易度 | ★☆☆ | ★★☆ |

次のステップ: [加速度チューニングガイド](./acceleration_tuning_guide.md) でパラメータ調整を行ってください。