import processing.serial.*;

Serial myPort;
ArrayList<PlayerData> players = new ArrayList<PlayerData>();
final int MAX_PLAYERS = 20;
boolean portConnected = false;
String statusMessage = "Initializing...";
int connectionAttempts = 0;
final int MAX_CONNECTION_ATTEMPTS = 5;

// ゲーム状態管理
final int STATE_IDLE = 0;
final int STATE_PLAYING = 1;
final int STATE_WIN = 2;

final int PHASE_CHARGE = 1;
final int PHASE_RESIST = 2;

int gameState = STATE_IDLE;
int currentPhase = PHASE_CHARGE;
float phaseStartTime = 0;
final float PHASE_DURATION = 10000;  // 10秒
float[] teamGauge = {0, 0};  // Team A(0), Team B(1)
final float GOAL_GAUGE = 100.0;

// ゲージ計算パラメータ
final float ACCEL_THRESHOLD = 5000;
final float GAUGE_COEFFICIENT = 0.00005;  // Accel値に掛ける係数

// フェーズ変更通知
int phaseNotificationTime = 0;
final int PHASE_NOTIFICATION_DURATION = 1500;  // 1.5秒表示

// 勝利表示
int winTeam = -1;
int winStartTime = 0;
final int WIN_SCREEN_DURATION = 5000;  // 5秒表示

class PlayerData {
  int id;
  int shakeCount;
  float acceleration;
  
  PlayerData(int id) {
    this.id = id;
    this.shakeCount = 0;
    this.acceleration = 0;
  }
  
  int getTeamID() {
    return id < 10 ? 0 : 1;
  }
}

void setup() {
  size(1600, 900);
  
  // フォント設定（メイリオ）
  PFont meiryoFont = createFont("Meiryo", 16);
  textFont(meiryoFont);
  
  println("=== Available Serial Ports ===");
  String[] ports = Serial.list();
  for (int i = 0; i < ports.length; i++) {
    println("[" + i + "] " + ports[i]);
  }
  println("==============================");
  
  // プレイヤーデータ初期化
  for (int i = 0; i < MAX_PLAYERS; i++) {
    players.add(new PlayerData(i));
  }
  
  connectToPort();
}

void connectToPort() {
  String[] ports = Serial.list();
  
  if (ports.length == 0) {
    statusMessage = "ERROR: ポートが見つかりません";
    println(statusMessage);
    return;
  }
  
  int portIndex = 0;
  
  try {
    if (myPort != null) {
      myPort.stop();
      delay(500);
    }
    
    println("Attempting to connect to: " + ports[portIndex]);
    myPort = new Serial(this, ports[portIndex], 115200);
    myPort.bufferUntil('\n');
    
    portConnected = true;
    statusMessage = "接続完了";
    println(statusMessage);
    connectionAttempts = 0;
    gameState = STATE_PLAYING;
    phaseStartTime = millis();
    phaseNotificationTime = millis();
    
  } catch (Exception e) {
    portConnected = false;
    connectionAttempts++;
    statusMessage = "接続失敗";
    println(statusMessage);
    
    if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
      println("再試行中...");
      delay(3000);
      connectToPort();
    }
  }
}

void draw() {
  // 背景
  background(10, 15, 30);
  
  if (!portConnected) {
    drawConnectionError();
    return;
  }
  
  // ゲーム状態管理
  updateGameState();
  
  // 背景グラデーション
  drawGameBackground();
  
  // ゲージ描画
  drawGauges();
  
  // フェーズ情報
  drawPhaseInfo();
  
  // フェーズ変更通知
  drawPhaseNotification();
  
  // プレイヤー情報
  drawPlayerInfo();
  
  // 状態表示
  drawStatus();
  
  // 勝利画面
  if (gameState == STATE_WIN) {
    drawWinScreen();
  }
}

void updateGameState() {
  if (gameState != STATE_PLAYING) return;
  
  float elapsedTime = millis() - phaseStartTime;
  
  if (elapsedTime > PHASE_DURATION) {
    switchPhase();
  }
  
  // 勝利条件チェック
  if (teamGauge[0] >= GOAL_GAUGE) {
    gameState = STATE_WIN;
    winTeam = 0;
    winStartTime = millis();
    println("チームAが勝利!");
    playWinSound();
  } else if (teamGauge[1] >= GOAL_GAUGE) {
    gameState = STATE_WIN;
    winTeam = 1;
    winStartTime = millis();
    println("チームBが勝利!");
    playWinSound();
  }
}

void switchPhase() {
  if (currentPhase == PHASE_CHARGE) {
    currentPhase = PHASE_RESIST;
    println("フェーズ切り替え: 抵抗フェーズへ");
  } else {
    currentPhase = PHASE_CHARGE;
    println("フェーズ切り替え: チャージフェーズへ");
  }
  phaseStartTime = millis();
  phaseNotificationTime = millis();
}

void drawConnectionError() {
  fill(200, 0, 0);
  textSize(32);
  textAlign(CENTER);
  text("ポート接続エラー", width/2, height/2 - 20);
  textSize(20);
  text("USBケーブルを確認してください", width/2, height/2 + 30);
}

void drawGameBackground() {
  // グラデーション背景
  for (int i = 0; i < height; i++) {
    float inter = map(i, 0, height, 0, 1);
    int c = lerpColor(color(10, 15, 30), color(30, 20, 50), inter);
    stroke(c);
    strokeWeight(1);
    line(0, i, width, i);
  }
}

void drawGauges() {
  int centerX = width / 2;
  int gaugeY = 150;
  int gaugeWidth = 80;
  int gaugeHeight = 400;
  int gaugeDistance = 320;
  
  // チームAゲージ（左）
  drawTeamGauge(centerX - gaugeDistance, gaugeY, gaugeWidth, gaugeHeight, 0, color(255, 80, 80));
  
  // チームBゲージ（右）
  drawTeamGauge(centerX + gaugeDistance, gaugeY, gaugeWidth, gaugeHeight, 1, color(80, 150, 255));
}

void drawTeamGauge(int x, int y, int w, int h, int teamID, color gaugeColor) {
  float gauge = teamGauge[teamID];
  float ratio = gauge / GOAL_GAUGE;
  int filledHeight = (int)(h * ratio);
  
  // 背景（枠）
  stroke(100, 100, 150);
  strokeWeight(4);
  fill(20, 20, 40);
  rect(x, y, w, h);
  
  // ゲージ本体
  fill(gaugeColor);
  rect(x, y + h - filledHeight, w, filledHeight);
  
  // 数値表示
  PFont meiryoFont = createFont("Meiryo", 36);
  textFont(meiryoFont);
  fill(255, 255, 200);
  textSize(36);
  textAlign(CENTER);
  text(nf(gauge, 0, 1), x + w/2, y + h + 50);
  
  // チーム名
  fill(gaugeColor);
  textSize(24);
  text(teamID == 0 ? "チームA" : "チームB", x + w/2, y - 25);
}

void drawPhaseInfo() {
  // 画面上部のフェーズ表示
  fill(0, 0, 0, 220);
  rect(0, 0, width, 130);
  
  PFont meiryoFont = createFont("Meiryo", 54);
  textFont(meiryoFont);
  fill(255);
  textSize(54);
  textAlign(CENTER);
  
  if (currentPhase == PHASE_CHARGE) {
    fill(100, 255, 100);
    text("フェーズ1: チャージ!", width/2, 65);
    fill(150, 255, 150);
    textSize(24);
    textFont(createFont("Meiryo", 24));
    text("振ってゲージを増やそう!", width/2, 100);
  } else {
    fill(255, 100, 100);
    text("フェーズ2: 危険!", width/2, 65);
    fill(255, 150, 150);
    textSize(24);
    textFont(createFont("Meiryo", 24));
    text("振るとゲージが減少します!", width/2, 100);
  }
  
  // 残り時間
  float elapsedTime = millis() - phaseStartTime;
  float remainingTime = max(0, PHASE_DURATION - elapsedTime) / 1000.0;
  fill(255, 255, 150);
  textSize(28);
  textAlign(RIGHT);
  textFont(createFont("Meiryo", 28));
  text(nf(remainingTime, 0, 1) + "秒", width - 40, 70);
}

void drawPhaseNotification() {
  float elapsed = millis() - phaseNotificationTime;
  
  if (elapsed < PHASE_NOTIFICATION_DURATION) {
    float alpha = map(elapsed, 0, PHASE_NOTIFICATION_DURATION, 255, 0);
    
    fill(0, 0, 0, alpha * 0.8);
    rect(0, 0, width, height);
    
    PFont meiryoFont = createFont("Meiryo", 72);
    textFont(meiryoFont);
    fill(255, 255, 100, alpha);
    textSize(72);
    textAlign(CENTER);
    
    if (currentPhase == PHASE_CHARGE) {
      text("チャージフェーズ開始!", width/2, height/2);
    } else {
      text("抵抗フェーズ開始!", width/2, height/2);
    }
  }
}

void drawPlayerInfo() {
  int cols = 10;
  int rows = 2;
  int boxWidth = width / cols;
  int boxHeight = 120;
  
  for (int i = 0; i < MAX_PLAYERS; i++) {
    int row = i / cols;
    int col = i % cols;
    
    int x = col * boxWidth;
    int y = height - (2 - row) * boxHeight;
    
    drawPlayerBox(x, y, boxWidth, boxHeight, players.get(i));
  }
}

void drawPlayerBox(int x, int y, int w, int h, PlayerData player) {
  color teamColor = player.getTeamID() == 0 ? color(255, 100, 100) : color(100, 150, 255);
  
  stroke(teamColor);
  strokeWeight(2);
  fill(20, 20, 40);
  rect(x + 3, y + 3, w - 6, h - 6);
  
  PFont meiryoFont = createFont("Meiryo", 14);
  textFont(meiryoFont);
  fill(teamColor);
  textSize(14);
  textAlign(CENTER);
  text("P" + player.id, x + w/2, y + 20);
  
  fill(255, 255, 100);
  textSize(22);
  textFont(createFont("Meiryo", 22));
  text(player.shakeCount, x + w/2, y + h/2 + 5);
  
  fill(150);
  textSize(10);
  textFont(createFont("Meiryo", 10));
  text(nf(player.acceleration, 0, 0), x + w/2, y + h - 10);
}

void drawStatus() {
  PFont meiryoFont = createFont("Meiryo", 12);
  textFont(meiryoFont);
  fill(100);
  textSize(12);
  textAlign(LEFT);
  if (portConnected) {
    fill(0, 200, 0);
    text("ステータス: " + statusMessage, 10, 20);
  } else {
    fill(200, 0, 0);
    text("ステータス: " + statusMessage, 10, 20);
  }
}

void drawWinScreen() {
  float elapsedWinTime = millis() - winStartTime;
  
  // フェード背景
  float bgAlpha = map(elapsedWinTime, 0, 1000, 0, 220);
  fill(0, 0, 0, bgAlpha);
  rect(0, 0, width, height);
  
  // メインテキスト
  float textAlpha = map(elapsedWinTime, 0, 500, 0, 255);
  PFont meiryoFont = createFont("Meiryo", 96);
  textFont(meiryoFont);
  
  fill(255, 255, 100, textAlpha);
  textSize(96);
  textAlign(CENTER);
  
  if (winTeam == 0) {
    text("チームAの勝利!", width/2, height/2 - 80);
  } else {
    text("チームBの勝利!", width/2, height/2 - 80);
  }
  
  textSize(48);
  textFont(createFont("Meiryo", 48));
  text("おめでとうございます!", width/2, height/2 + 80);
  
  // 一定時間経過後、自動リセット
  if (elapsedWinTime > WIN_SCREEN_DURATION) {
    resetGame();
  }
}

void resetGame() {
  println("ゲームをリセット");
  gameState = STATE_PLAYING;
  teamGauge[0] = 0;
  teamGauge[1] = 0;
  winTeam = -1;
  currentPhase = PHASE_CHARGE;
  phaseStartTime = millis();
  phaseNotificationTime = millis();
}

void serialEvent(Serial myPort) {
  if (!portConnected) return;
  
  try {
    String inString = myPort.readStringUntil('\n');
    
    if (inString != null) {
      inString = trim(inString);
      
      // デバッグ行をスキップ
      if (inString.startsWith("Child #") || inString.startsWith("DEBUG") || 
          inString.startsWith("Shake") || inString.startsWith("ESP-NOW") ||
          inString.startsWith("Parent") || inString.startsWith("Ready") ||
          inString.startsWith("===") || inString.startsWith("Jerk") ||
          inString.startsWith("Accel") || inString.startsWith("Initialized") ||
          inString.startsWith(">>>") || inString.startsWith("フェーズ") ||
          inString.startsWith("Reset")) {
        return;
      }
      
      if (inString.startsWith("CMD")) {
        return;
      }
      
      // CSV形式のデータ処理: childID,shakeCount,acceleration
      String[] parts = split(inString, ',');
      
      if (parts.length >= 3) {
        try {
          int childID = int(parts[0]);
          int shakeCount = int(parts[1]);
          float acceleration = float(parts[2]);
          
          if (childID >= 0 && childID < MAX_PLAYERS) {
            PlayerData player = players.get(childID);
            
            // シェイク検知：カウントが増えたか確認
            if (shakeCount > player.shakeCount && gameState == STATE_PLAYING) {
              int teamID = player.getTeamID();
              
              // ゲージ計算: Accel × 係数
              float gaugeIncrease = acceleration * GAUGE_COEFFICIENT;
              if (currentPhase == PHASE_RESIST) {
                gaugeIncrease = -gaugeIncrease;
              }
              
              teamGauge[teamID] += gaugeIncrease;
              teamGauge[teamID] = constrain(teamGauge[teamID], 0, GOAL_GAUGE);
              
              println("チーム" + (teamID == 0 ? "A" : "B") + " - Accel: " + acceleration + " - Gauge増加: " + gaugeIncrease);
              
              // 効果音再生（別スレッド）
              if (currentPhase == PHASE_CHARGE) {
                thread("playCoinSoundThread");
              } else {
                thread("playPenaltySoundThread");
              }
            }
            
            player.shakeCount = shakeCount;
            player.acceleration = acceleration;
          }
        } catch (Exception e) {
          println("解析エラー: " + inString);
        }
      }
    }
  } catch (Exception e) {
    println("シリアルエラー: " + e.getMessage());
    portConnected = false;
    statusMessage = "接続切断";
  }
}

// ★ コイン効果音（別スレッド）
void playCoinSoundThread() {
  try {
    java.awt.Toolkit.getDefaultToolkit().beep();
    delay(50);
    java.awt.Toolkit.getDefaultToolkit().beep();
  } catch (Exception e) {
  }
}

// ペナルティ音（別スレッド）
void playPenaltySoundThread() {
  try {
    java.awt.Toolkit.getDefaultToolkit().beep();
    delay(100);
    java.awt.Toolkit.getDefaultToolkit().beep();
    delay(50);
    java.awt.Toolkit.getDefaultToolkit().beep();
  } catch (Exception e) {
  }
}

// 勝利音（別スレッド）
void playWinSound() {
  thread("playWinSoundThread");
}

void playWinSoundThread() {
  try {
    java.awt.Toolkit.getDefaultToolkit().beep();
    delay(100);
    java.awt.Toolkit.getDefaultToolkit().beep();
    delay(100);
    java.awt.Toolkit.getDefaultToolkit().beep();
  } catch (Exception e) {
  }
}

void keyPressed() {
  if (key == 'r' || key == 'R') {
    println("再接続中...");
    connectionAttempts = 0;
    connectToPort();
  }
  
  if (key == ' ') {
    switchPhase();
  }
}
